package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path"

	"github.com/forj-oss/goforjj"
)

// This file describes how we generate source from templates.

// loop on files to simply copy
func (p *JenkinsPlugin) copy_source_files(ret *goforjj.PluginData, status *bool) (err error) {
	for file, desc := range p.sources {
		sourceStatus := false
		src := path.Join(p.template_dir, desc.Source)
		dest := path.Join(p.deployPath, desc.Source)

		if sourceStatus, err = p.copyFile(src, dest, desc.Chmod); err != nil {
			log.Printf(ret.Errorf("%s.", err))
		} else if sourceStatus {
			IsUpdated(status)
			log.Printf("Deploy: Copied '%s' to '%s'", src, dest)
			log.Printf(ret.StatusAdd("Deploy: %s (%s) copied.", file, desc.Source))
			ret.AddFile(goforjj.FilesDeploy, path.Join(p.InstanceName, desc.Source))
		} else {
			log.Printf("Deploy: '%s' not updated.", dest)
		}
	}
	return
}

// copyGeneratedSourceFiles copy all generated source files, available in the source repo.
func (p *JenkinsPlugin) copyGeneratedSourceFiles(ret *goforjj.PluginData, status *bool) (err error) {
	for file, desc := range p.generated {
		sourceStatus := false
		src := path.Join(p.source_path, desc.Generated)
		dest := path.Join(p.deployPath, desc.Generated)

		if _, err := os.Stat(src); err != nil {
			log.Printf("Deploy: copy '%s' to '%s' is ignored as source is currently not found. %s", src, dest, err)
		}
		if sourceStatus, err = p.copyFile(src, dest, desc.Chmod); err != nil {
			log.Printf(ret.Errorf("%s.", err))
		} else if sourceStatus {
			IsUpdated(status)
			log.Printf("Deploy: Copied generated '%s' to '%s'", src, dest)
			log.Printf(ret.StatusAdd("Deploy: Generated %s (%s) copied.", file, desc.Generated))
			ret.AddFile(goforjj.FilesDeploy, path.Join(p.InstanceName, desc.Generated))
		} else {
			log.Printf("Deploy: Generated '%s' not updated.", dest)
		}
	}
	return
}

// copyFile do a file copy from a source repo to a deploy repo.
func (p *JenkinsPlugin) copyFile(src, dest string, chmod os.FileMode) (status bool, err error) {
	parent := path.Dir(dest)

	if parent != "." {
		if _, err = os.Stat(parent); err != nil {
			log.Printf("Creating '%s'.", parent)
			if err = os.MkdirAll(parent, 0755); err != nil {
				err = fmt.Errorf("Unable to copy '%s' to '%s'. %s", src, dest, err)
				return
			}
		}
	}

	destMD5, _ := md5sum(dest)

	if _, errMD5, m5 := Copy(src, dest); errMD5 != nil {
		err = fmt.Errorf("Unable to copy '%s' to '%s'. %s", src, dest, errMD5)
		return
	} else {
		status = (destMD5 == nil || !bytes.Equal(destMD5, m5))
	}

	var sourceStatus bool
	sourceStatus, err = set_rights(dest, chmod)
	if sourceStatus {
		status = true
	}
	return
}

func set_rights(file string, rights os.FileMode) (updated bool, _ error) {
	if rights == 0 {
		log.Printf("No rights to apply to %s.", file)
		return
	}

	log.Printf("Checking %s rights.", file)

	var rightsb os.FileMode
	stat_found := false
	if r, err := os.Stat(file); err == nil {
		rightsb = r.Mode()
		stat_found = true
	}
	if err := os.Chmod(file, rights); err != nil {
		return false, fmt.Errorf("Unable to set rights to '%s' with '%d'. %s", file, rights, err)
	}
	if stat_found {
		updated = (rightsb != rights)
	} else {
		updated = true
		log.Printf("%s rights updated from %d to %d.", file, rightsb, rights)
	}
	return
}

// loop on templates to use to generate source files
// The based data used for template is conform to the content of
// the forjj-jenkins.yaml file
// See YamlJenkins in jenkins_plugin.go
func (p *JenkinsPlugin) generate_source_files(ret *goforjj.PluginData, status *bool) (_ error) {
	for file, desc := range p.templates {
		if s, err := desc.Generate(p.yaml, p.template_dir, p.deployPath, desc.Template); err != nil {
			log.Printf(ret.Errorf("%s", err))
			return err
		} else if s {
			ret.AddFile(goforjj.FilesDeploy, path.Join(p.InstanceName, desc.Template))
			log.Printf(ret.StatusAdd("Deploy: %s (%s) generated", file, desc.Template))
			IsUpdated(status)
		} else {
			log.Printf("Deploy: %s (%s) not updated", file, desc.Template)
		}
	}

	return
}

func (p *JenkinsPlugin) addBuiltFiles(ret *goforjj.PluginData, updated *bool) (err error) {
	for file, desc := range p.built {
		fileBuilt := path.Join(p.InstanceName, desc.Built)
		if info, err := os.Stat(desc.Built); err == nil {
			if info.IsDir() {
				err = fmt.Errorf("%s is a directory. Cannot be added to controlled files by Forjj/git", fileBuilt)
				log.Printf(ret.Errorf("%s", err))
				return err
			}
			ret.AddFile(goforjj.FilesDeploy, fileBuilt)
			log.Printf(ret.StatusAdd("Deploy: %s (%s) built by `run_build` process.", file, desc.Built))
		} else {
			log.Printf(ret.Errorf("%s has not been built by run_build command", fileBuilt))
			return err

		}
	}
	return nil
}

// addGeneratedFiles add files generated by a build task in source and copy it to the deploy repository
func (p *JenkinsPlugin) addGeneratedFilesFor(taskName string, ret *goforjj.PluginData, updated *bool) (err error) {
	for file, desc := range p.generated {
		if desc.GeneratedTask != taskName {
			continue
		}
		sourceStatus := false
		src := path.Join(p.source_path, desc.Generated)
		dest := path.Join(p.deployPath, desc.Generated)

		if stat, err := os.Stat(src); err != nil {
			return fmt.Errorf("Issue with the generated source file '%s'. %s", src, err)
		} else if !stat.Mode().IsRegular() {
			return fmt.Errorf("Issue with '%s'. '%s' is not a regular file", src, src)
		}

		sourceMD5, _ := md5sum(src)
		if !bytes.Equal(sourceMD5, desc.md5Generated) {
			IsUpdated(updated)
			log.Printf("Source: Generated '%s' has been created/updated by a run-task.", src)
			ret.StatusAdd("Source: %s (%s) created/updated by a run-task.", file, desc.Generated)
			ret.AddFile(goforjj.FilesSource, path.Join(p.InstanceName, desc.Generated))
		}

		if sourceStatus, err = p.copyFile(src, dest, desc.Chmod); err != nil {
			log.Printf(ret.Errorf("%s.", err))
		} else if sourceStatus {
			IsUpdated(updated)
			log.Printf("Deploy: Copied generated '%s' to '%s'", src, dest)
			ret.StatusAdd("Deploy: Generated %s (%s) copied.", file, desc.Generated)
			ret.AddFile(goforjj.FilesDeploy, path.Join(p.InstanceName, desc.Generated))
		} else {
			log.Printf("Deploy: '%s' not updated.", dest)
		}
	}
	return nil
}
